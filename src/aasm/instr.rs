/// Instruction with a generic register type.
/// First argument is destination, second is source.
#[derive(Debug, Clone)]
pub enum Instr<R> {
    MoveR(R, R),
    MoveI(R, i32),

    NegR(R, R),

    AddRR(R, [R; 2]),
    AddRI(R, R, i32),

    // there is no `SubRI(d, s, i)`, because it is the same as `AddRI(d, s, -i)`
    SubRR(R, [R; 2]),
    SubIR(R, i32, R),

    IMulRR(R, [R; 2]),
    IMulRI(R, R, i32),

    DivModRR([R; 2], [R; 2]),
    DivModRI([R; 2], R, i32),
    DivModIR([R; 2], i32, R),

    ReturnR(R),
    ReturnI(i32),
}

macro_rules! impl_split {
    ($slf:ident, $f:path, $e:expr) => {
        match $slf {
            Self::ReturnI(_) => ($e, $e),
            Self::MoveI(d, _) => ($f(d), $e),
            Self::ReturnR(s) => ($e, $f(s)),
            Self::MoveR(d, s)
            | Self::NegR(d, s)
            | Self::AddRI(d, s, _)
            | Self::SubIR(d, _, s)
            | Self::IMulRI(d, s, _) => ($f(d), $f(s)),
            Self::AddRR(d, s) | Self::SubRR(d, s) | Self::IMulRR(d, s) => ($f(d), s),
            Self::DivModRI(d, s, _) | Self::DivModIR(d, _, s) => (d, $f(s)),
            Self::DivModRR(d, s) => (d, s),
        }
    };
}

impl<R> Instr<R> {
    pub const fn split_regs_dst_src(&self) -> (&[R], &[R]) {
        impl_split!(self, core::slice::from_ref, &[])
    }

    pub const fn split_regs_dst_src_mut(&mut self) -> (&mut [R], &mut [R]) {
        impl_split!(self, core::slice::from_mut, &mut [])
    }

    pub fn dst_regs(&self) -> &[R] {
        self.split_regs_dst_src().0
    }

    pub fn src_regs(&self) -> &[R] {
        self.split_regs_dst_src().1
    }

    pub fn src_regs_mut(&mut self) -> &mut [R] {
        self.split_regs_dst_src_mut().1
    }

    pub fn regs_mut(&mut self) -> impl Iterator<Item = &mut R> {
        let (d, s) = self.split_regs_dst_src_mut();
        d.iter_mut().chain(s)
    }

    /// Replaces all registers that match `pattern` with a new register generated by `generate`.
    pub fn replace_all(&mut self, pattern: &R, mut generate: impl FnMut() -> R)
    where
        R: Eq,
    {
        self.regs_mut()
            .filter(|reg| *reg == pattern)
            .for_each(|reg| *reg = generate())
    }

    /// Replaces source registers that match `pattern` with a new register generated by `generate`.
    pub fn replace_srcs(&mut self, pattern: &R, mut generate: impl FnMut() -> R)
    where
        R: Eq,
    {
        self.src_regs_mut()
            .iter_mut()
            .filter(|reg| *reg == pattern)
            .for_each(|reg| *reg = generate())
    }
}
