use crate::parser::ast::IntLit;

/// Instruction with a generic register type.
/// First argument is destination, second is source.
#[derive(Debug, Clone)]
pub enum Instr<R> {
    LoadConst(R, IntLit),
    Move(R, R),
    Neg(R, R),
    Add(R, [R; 2]),
    Sub(R, [R; 2]),
    Mul(R, [R; 2]),
    Div(R, [R; 2]),
    Mod(R, [R; 2]),
    Return(R),
}

impl<R> Instr<R> {
    pub const fn split_regs_dst_src(&self) -> (Option<&R>, &[R]) {
        match self {
            Self::LoadConst(d, _) => (Some(d), &[]),
            Self::Move(d, s) | Self::Neg(d, s) => (Some(d), core::slice::from_ref(s)),
            Self::Add(d, s)
            | Self::Sub(d, s)
            | Self::Mul(d, s)
            | Self::Div(d, s)
            | Self::Mod(d, s) => (Some(d), s),
            Self::Return(s) => (None, core::slice::from_ref(s)),
        }
    }

    pub const fn split_regs_dst_src_mut(&mut self) -> (Option<&mut R>, &mut [R]) {
        match self {
            Self::LoadConst(d, _) => (Some(d), &mut []),
            Self::Move(d, s) | Self::Neg(d, s) => (Some(d), core::slice::from_mut(s)),
            Self::Add(d, s)
            | Self::Sub(d, s)
            | Self::Mul(d, s)
            | Self::Div(d, s)
            | Self::Mod(d, s) => (Some(d), s),
            Self::Return(s) => (None, core::slice::from_mut(s)),
        }
    }

    pub fn dst_reg(&self) -> Option<&R> {
        self.split_regs_dst_src().0
    }

    pub fn regs_mut(&mut self) -> impl Iterator<Item = &mut R> {
        let (d, s) = self.split_regs_dst_src_mut();
        d.into_iter().chain(s)
    }

    /// Replaces all registers that match `pattern` with a new register generated by `generate`.
    pub fn replace_all(&mut self, pattern: &R, mut generate: impl FnMut() -> R)
    where
        R: Eq,
    {
        self.regs_mut()
            .filter(|reg| *reg == pattern)
            .for_each(|reg| *reg = generate())
    }
}
